
import { supabase } from './supabaseClient';
import { Person, Sector, Job } from '../types';

// Sectors
export const getSectors = async (): Promise<Sector[]> => {
    const { data, error } = await supabase.from('sectors').select('*').order('name');
    if (error) {
        console.error('Error fetching sectors:', error);
        return [];
    }
    return data || [];
};

export const createSector = async (sector: Sector): Promise<Sector | null> => {
    // We exclude 'id' if it's auto-generated by DB or we can pass it if we want to control UUIDs client-side.
    // Ideally let DB handle ID, but app might expect ID immediately.
    // If the app generates ID before calling this (e.g. Date.now()), we might want to ignore it and use DB's UUID,
    // OR we can just use the provided ID if it is a valid UUID, but here the app uses string IDs (often Date.now()).
    // Supabase expects UUIDs for the ID column.
    // Strategy: We will let Supabase generate UUID. The App's UI might be using Date.now() for optimistic UI.
    // We should adapt the app to use the returned ID, or if strict UUID is required, we can't use Date.now().

    const { data, error } = await supabase
        .from('sectors')
        .insert([{ name: sector.name }])
        .select()
        .single();

    if (error) {
        console.error('Error creating sector:', error);
        return null;
    }
    return data;
};

export const updateSector = async (sector: Sector): Promise<Sector | null> => {
    const { data, error } = await supabase
        .from('sectors')
        .update({ name: sector.name })
        .eq('id', sector.id)
        .select()
        .single();

    if (error) {
        console.error('Error updating sector:', error);
        return null;
    }
    return data;
};

export const deleteSector = async (id: string): Promise<boolean> => {
    const { error } = await supabase.from('sectors').delete().eq('id', id);
    if (error) {
        console.error('Error deleting sector:', error);
        return false;
    }
    return true;
};

// Jobs
export const getJobs = async (): Promise<Job[]> => {
    const { data, error } = await supabase.from('jobs').select('*').order('name');
    if (error) {
        console.error('Error fetching jobs:', error);
        return [];
    }
    return data || [];
};

export const createJob = async (job: Job): Promise<Job | null> => {
    const { data, error } = await supabase
        .from('jobs')
        .insert([{ name: job.name }])
        .select()
        .single();

    if (error) {
        console.error('Error creating job:', error);
        return null;
    }
    return data;
};

export const updateJob = async (job: Job): Promise<Job | null> => {
    const { data, error } = await supabase
        .from('jobs')
        .update({ name: job.name })
        .eq('id', job.id)
        .select()
        .single();

    if (error) {
        console.error('Error updating job:', error);
        return null;
    }
    return data;
};

export const deleteJob = async (id: string): Promise<boolean> => {
    const { error } = await supabase.from('jobs').delete().eq('id', id);
    if (error) {
        console.error('Error deleting job:', error);
        return false;
    }
    return true;
};

// Persons
export const getPersons = async (): Promise<Person[]> => {
    const { data, error } = await supabase.from('persons').select('*').order('name');
    if (error) {
        console.error('Error fetching persons:', error);
        return [];
    }
    // Map snake_case to camelCase
    return data?.map(p => ({
        id: p.id,
        name: p.name,
        sectorId: p.sector_id,
        jobId: p.job_id
    })) || [];
};

export const createPerson = async (person: Person): Promise<Person | null> => {
    const { data, error } = await supabase
        .from('persons')
        .insert([{
            name: person.name,
            sector_id: person.sectorId,
            job_id: person.jobId
        }])
        .select()
        .single();

    if (error) {
        console.error('Error creating person:', error);
        return null;
    }
    return {
        id: data.id,
        name: data.name,
        sectorId: data.sector_id,
        jobId: data.job_id
    };
};

export const updatePerson = async (person: Person): Promise<Person | null> => {
    const { data, error } = await supabase
        .from('persons')
        .update({
            name: person.name,
            sector_id: person.sectorId,
            job_id: person.jobId
        })
        .eq('id', person.id)
        .select()
        .single();

    if (error) {
        console.error('Error updating person:', error);
        return null;
    }
    return {
        id: data.id,
        name: data.name,
        sectorId: data.sector_id,
        jobId: data.job_id
    };
};

export const deletePerson = async (id: string): Promise<boolean> => {
    const { error } = await supabase.from('persons').delete().eq('id', id);
    if (error) {
        console.error('Error deleting person:', error);
        return false;
    }
    return true;
};
